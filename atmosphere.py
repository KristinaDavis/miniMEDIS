"""
atmosphere.py

For mini-medis, code copied over from atmos.py and aberrations.py from Rupert's original MEDIS

Contains functions that will create, load, save, and apply atmospheric maps
"""
import numpy as np
import os
import astropy.io.fits as fits
import hcipy
import proper
from skimage.restoration import unwrap_phase

from mm_params import iop, ap, tp, sp, atmp
from mm_utils import dprint
import optics as opx


def gen_atmos(plot=False):
    """
    generates atmospheric phase distortions using hcipy (updated from original using CAOS)

    read more on HCIpy here: https://hcipy.readthedocs.io/en/latest/index.html
    In hcipy, the atmosphere evolves as a function of time, specified by the user. User can thus specify the
    timescale of evolution through both velocity of layer and time per step in the obs_sequence, in loop for
    mini_medis.gen_timeseries().

    :param plot: turn plotting on or off
    :return:
    """
    dprint("Making New Atmosphere Model")

    pupil_grid = hcipy.make_pupil_grid(tp.grid_size, tp.enterance_d)

    if atmp.model == 'single':
        layers = [hcipy.InfiniteAtmosphericLayer(pupil_grid, atmp.cn_sq, atmp.L0, atmp.vel, atmp.h, 2)]
    elif atmp.model == 'hcipy_standard':
        # Make multi-layer atmosphere
        layers = hcipy.make_standard_atmospheric_layers(pupil_grid, atmp.outer_scale)
    elif atmp.model == 'evolving':
        raise NotImplementedError

    atmos = hcipy.MultiLayerAtmosphere(layers, scintilation=False)

    wsamples = np.linspace(ap.wvl_range[0], ap.wvl_range[1], ap.nwsamp)
    dprint(f"{wsamples}")
    wavefronts = []

    for wavelength in wsamples:
        wavefronts.append(hcipy.Wavefront(hcipy.Field(np.ones(pupil_grid.size), pupil_grid), wavelength))

    for it, t in enumerate(np.arange(0, sp.numframes*sp.sample_time, sp.sample_time)):
        atmos.evolve_until(t)
        for iw, wf in enumerate(wavefronts):
            wf2 = atmos.forward(wf)

            filename = get_filename(it, wsamples[iw])
            hdu = fits.ImageHDU(wf2.phase.reshape(tp.grid_size, tp.grid_size))
            hdu.header['PIXSIZE'] = tp.enterance_d/tp.grid_size
            hdu.writeto(filename, overwrite=True)

            if plot:
                import matplotlib.pyplot as plt
                from twilight_colormaps import sunlight
                plt.figure()
                plt.title(f"Atmosphere Phase Map t={t} lambda={eformat(wsamples[iw], 3, 2)}")
                hcipy.imshow_field(wf2.phase, cmap=sunlight)
                plt.colorbar()
                plt.show(block=True)


def add_atmos(wfo, it):
    """
    creates a phase offset matrix for each wavelength at each time step,
    sampled from the atmosphere generated by hcipy

    :param wfo: class object containing complex E-field arrays at each wavelength for each astronomical body
    :param it: timestep# in obs_sequence. Comes from mini_medis.gen_timeseries()
    :return:
    """
    shape = wfo.wf_array.shape

    for iw in range(shape[0]):
        wavelength = wfo.wf_array[iw, 0].lamda  # the .lamda comes from proper, not from Wavefronts class
        atmos_map = get_filename(it, wavelength)
        if not os.path.exists(atmos_map):
            raise NameError('Failed to initialize atmosphere in mini_medis.run_medis() \n'
                            'check new atmosphere is generated for specific mm_params \n'
                            'Check: tp.grid_size, ap.numframes, etc')

        for io in range(shape[1]):
            obj_map = fits.open(atmos_map)[1].data
            obj_map = unwrap_phase(obj_map)
            obj_map *= wavelength/np.pi
            proper.prop_add_phase(wfo.wf_array[iw,io], obj_map)

    # Spatial Masking outside of Telescope Aperture -depricated when using mask_obs_sequence
    # wfo.wf_array = opx.abs_zeros(wfo.wf_array)  # Zeroing outside the pupil
    # wfo.loop_func(proper.prop_circular_aperture, tp.enterance_d/2)


def rotate_atmos(wf, it):
    time = it * ap.sample_time
    rotate_angle = tp.rot_rate * time
    wf.wfarr = proper.prop_shift_center(wf.wfarr)
    wf.wfarr = proper.prop_rotate(wf.wfarr, rotate_angle)
    wf.wfarr = proper.prop_shift_center(wf.wfarr)


def eformat(wvl, prec, exp_digits):
    """
    reformats wavelength into scientific notation in meters

    :param wvl: wavelength float
    :param prec: precision
    :param exp_digits: number of digits in the exponent
    :return:
    """
    s = "%.*e" % (prec, wvl)
    mantissa, exp = s.split('e')
    # add 1 to digits as 1 is taken by sign +/-
    return "%se%+0*d" % (mantissa, exp_digits + 1, int(exp))


def get_filename(it, lamda):
    """
    returns the atmosphere map names in the format location/atmos_t<time>_<model>_wvl<wavelength>
    example output:

    :param it: time index
    :param lamda: wavelength, comes from metadata in proper wavefront object (ie wfo.wf_array.lamda)
    :return:
    """
    wave = eformat(lamda, 3, 2)
    return f'{iop.atmosdir}/atmos_t{sp.sample_time*it:.3f}_{atmp.model}_wvl{wave}.fits'

